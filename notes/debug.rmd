# Debugging in R #

Local Scope

First off, in our discussion about functions, I omitted an important topic (due to time constrants): R functions have a sort of “local” existence (I'm simplifying here to avoid computer science jargon, but for a full treatment, see this Wikipedia entry). I can illustrate this with a quick example.

``` {r}
y <- 14
a <- "another value"

g <- function() {
    y <- pi
    message(sprintf("in function 'g', y=%f\n", y))
    message(sprintf("in function 'g', a=%s\n", a))
}

f <- function() {
    y <- 3
    a <- "note that we're setting a here too, look what happens in g!"
    message(sprintf("in function 'f', y=%f\n", y))
    g()
    return(NULL)
}

message(sprintf("outside both functions, y=%f", y))
```

``` {r calling_f}
f()
```

Study this output carefully. This is called lexical scoping (versus dynamic scoping). Again, you can probably not worry too much about this, but it's good to know about so you can look it up for reference (in the R Language Definition for example) if you run into trouble.

The main point here is that when `f()` called `g()`, and `g()` looks for `a`, it won't look in `f()` (which is above `g()`), but rather the global environment. Why? Because we created f in the global environment, and functions figure out where to look for things in their enclosing environment.

Don't panic if this is unclear. Play around with examples. In most cases it won't bite you, but if it does, you can use debugging tools to help you!

## Options and Recover

The function recover allows you to browser where you are in a series of “nested” function calls (also called the call stack). Figuring out what values are what can really help you in debugging. For example, I'm going to create an artificial error (with stop()) and show you how to cruise around.

``` {r}
g <- function() {
  b <- 10
  stop()
}

f <- function() {
  a <- 10
  b <- 13
  g()
}
```

Now, my comments as I debug are below:

	f() ## call the function
	Error in g() : ## Eargh! And error!!
	> options(error=recover) ## We set options(error=recover)
	> f() ## Re call function
	Error in g() : 

	Enter a frame number, or 0 to exit   

	1: f()
	2: #4: g()

	Selection: 1 ### I select 1, which brings me in the scope of f
	Called from: top level 
	Browse[1]> ls()
	[1] "a" "b"
	Browse[1]> a
	[1] 10
	Browse[1]> b
	[1] 13
	Browse[1]> ## Here I press enter to get that selection list again

	Enter a frame number, or 0 to exit   

	1: f()
	2: #4: g()

	Selection: 2 ## 2 brings me to the scope of g
	Called from: f()
	Browse[1]> ls()
	[1] "b"
	Browse[1]> b
	[1] 10  # b is no different in g's scope
	Browse[1]>

In “Browse”, hit `Q` and press enter to quite, or press enter to be brought back to the function stack selection list.

Turn off this option with `options(error=NULL)`.

## Browser

`recover()` uses `browser()`, but we can also use it directly:

``` {r}
f <- function(x) {
  a <- 3
  b <- 4
  browser()
}
```

## Debug

Lastly, we can step through code by calling `debug(yourFunctionName)`. See `?debug` for full details in the documentation.