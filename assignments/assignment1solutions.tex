\documentclass[11pt]{exam}
\usepackage{listings}
\usepackage{pdfsync}

%
%  Created by Christopher J. Fonnesbeck on 2011-09-06.
%  Copyright (c) 2011 Vanderbilt University. All rights reserved.
%
%

% This is now the recommended way for checking for PDFLaTeX:
\usepackage{ifpdf}

%\newif\ifpdf
%\ifx\pdfoutput\undefined
%\pdffalse % we are not running PDFLaTeX
%\else
%\pdfoutput=1 % we are running PDFLaTeX
%\pdftrue
%\fi

\ifpdf
\usepackage{subfigure}
\usepackage[pdftex]{graphicx}
\else
\usepackage{graphicx}
\fi

%
%  Update these values for running headers
%
\firstpageheader{\bf\Large Bios 301}{\bf\Large Assignment 1}{\bf\Large
  2011-09-06 }
\runningheader{Bios 301}{}{Assignment 1 (Solutions)}
\addpoints

\begin{document}

\begin{center} 
  \fbox{\fbox{\parbox{5.5in}{\centering This assignment is due in electronic format on 19 September, 2011 at Noon. There are
      \numquestions\  questions for a total of  \numpoints\ points.}}}
\end{center} 

% setup standard options for the including code fragments
\lstset{language=Python,numbers=left}

\vspace{0.1in} 
% \hbox to \textwidth{Name:\enspace\hrulefill} 

All questions are from Jones, Maillardet and Robinson, ``Scientific Programming and Simulation using R". Note that for most programming problems, there is usually more than one possible solution!

% Questions start here:
\begin{questions}
	
\question[7] Chapter 2: Questions 2, 4. 

\begin{enumerate}
	\item[2:]
	
	\begin{enumerate}
		\item \verb!c(seq(1,8),seq(7,1))!
		\item \verb!rep(1:5, 1:5)!
		\item \verb!(diag(3)==0) * 1!
		\item \verb|matrix(sapply(1:9, function(x) ifelse(x %in% c(2,3,5,7), x, 0)), nrow=3, byrow=T)|
		
	\end{enumerate}
	
	
	\item[4:] \verb!which((1:100)%%2>0 & (1:100)%%3>0 & (1:100)%%7>0)!
	
	
\end{enumerate}

\question[12] Chapter 3: Questions 1, 2, 4, 7, 11.

\begin{enumerate}
	\item[1:]
	
	\begin{verbatim}
		# input
		x.values <- seq(-2, 2, by = 0.1)

		# for each x calculate y
		n <- length(x.values)
		y.values <- rep(0, n)

		for (i in 1:n) {
			x <- x.values[i]
			if (x<=0) {
			    y.values[i] <- -x^3
			} else if (x<=1){
			    y.values[i] <- x^2
			} else {
			    y.values[i] <- sqrt(x)
			}
		}

		# output
		plot(x.values, y.values, type = "l")
	\end{verbatim}
	
	The function is differentiable at zero, but not one.
	
	\item[2:] 
	
	\begin{verbatim}
	
		x <- 3
		n <- 5
	    value <- 1

	    for (i in 1:n) {
	        value <- value + x^i
	    }

	\end{verbatim}
	
	\item[4:]
	
	\begin{verbatim}
		hwhile <- function(x, n) {

		    value <- 1
		    i <- 1
		    while (i<=n) {
		        value <- value + x^i
		        i <- i+1
		    }

		    value
		}
	\end{verbatim}
	
	\item[7:]
	
	Here's one way: \verb!sum(x[seq(1,length(x),by=3)])!
	
	\item[11:]
	
	\begin{verbatim}
		sortsorted <- function(x, y) {
		    # Initialize vector
		    xy <- NULL
		    # Copy y
		    y_remaining <- y
		    # Loop over x
		    for (xval in x) {
		        # Which values of y are smaller
		        y_smaller <- xval > y_remaining
		        # Add smaller y (if any), then current x
		        xy <- c(xy, y_remaining[y_smaller], xval)  
		        # Remove small values from remaining y
		        y_remaining <- y_remaining[!y_smaller]
		    }
		    xy
		}
	\end{verbatim} 
	
\end{enumerate}

\question[11] Chapter 5: Questions 2, 4, 5, 7.

\begin{enumerate}
	\item[2:] 
	
	\begin{verbatim}
		h <- function(x, n) {

		    value <- 1

		    for (i in 1:n) {
		        value <- value + x^i
		    }

		    value
		}
	\end{verbatim}
	
	\item[4:] The function sums \emph{all} of x, and not the first \emph{n} values. This is not a problem the first time, since x is not previously defined, but when it cannot find elements of x outside the range of the sampled vector, it looks for other x's in the enclosing environment.
	
	
	\item[5:] 
	
	\begin{verbatim}
		growth <- function(x, r, n) {

		    series <- numeric(n)
		    series[1] <- x
		    for (i in 2:n) {
		        series[i] <- r * series[i-1] * (1-series[i-1])
		    }

		    plot(1:n, series, type='b')

		}
	\end{verbatim}
	
	\item[7:]
	
	\begin{verbatim}
		nCr <- function(n, r) {
		    if (n==r | r==0) return(1)
		    nCr(n-1, r-1) + nCr(n-1, r)
		}
	\end{verbatim} 
	
\end{enumerate}

\end{questions}

\end{document}

